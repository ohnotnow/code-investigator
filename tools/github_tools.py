#!/usr/bin/env python3
"""
Simple GitHub repository creator module.
Requires: gh CLI tool to be installed and authenticated.
"""

import subprocess
import os
import re
import shutil
from pathlib import Path
from typing import Optional


class GitHubRepoCreator:
    def __init__(self, license_file_path: Optional[str] = None):
        """
        Initialize the GitHub repo creator.

        Args:
            license_file_path: Path to license file to copy (defaults to ~/.ghrc-license)
        """
        self.license_file_path = license_file_path or os.path.expanduser("~/.ghrc-license")

    def check_dependencies(self) -> None:
        """Check if required dependencies are installed."""
        for cmd in ['gh', 'git']:
            if not shutil.which(cmd):
                raise RuntimeError(f"{cmd} is required but not installed")

    def check_git_repo(self) -> None:
        """Check if we're in a git repository."""
        if not os.path.exists('.git'):
            raise RuntimeError("Not in a git repository")

    def create_repo(self, repo_name: str, is_public: bool = True) -> str:
        """
        Create a GitHub repository using gh CLI.

        Args:
            repo_name: Name of the repository to create
            is_public: Whether the repo should be public (default: True)

        Returns:
            The HTML URL of the created repository
        """
        self.check_dependencies()
        self.check_git_repo()

        visibility = "--public" if is_public else "--private"

        print(f"Creating GitHub repository '{repo_name}'...")

        try:
            result = subprocess.run([
                'gh', 'repo', 'create', repo_name,
                visibility, '--source', '.', '--remote=origin', '--push'
            ], capture_output=True, text=True, check=True)

            # Extract URL from output
            output = result.stdout
            url_match = re.search(r'https://github\.com/[^\s]+', output)

            if not url_match:
                raise RuntimeError(f"Failed to extract GitHub repo URL from output: {output}")

            html_url = url_match.group().rstrip('.git')
            print(f"✓ Created repository: {html_url}")
            return html_url

        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Failed to create repository: {e.stderr}")

    def copy_license(self) -> bool:
        """
        Copy license file if it exists and LICENSE doesn't already exist.

        Returns:
            True if license was copied, False otherwise
        """
        if not os.path.exists(self.license_file_path):
            return False

        if os.path.exists('LICENSE'):
            print("LICENSE file already exists, skipping copy")
            return False

        try:
            shutil.copy2(self.license_file_path, './LICENSE')
            subprocess.run(['git', 'add', 'LICENSE'], check=True)
            print("✓ License file copied and staged")
            return True
        except (OSError, subprocess.CalledProcessError) as e:
            print(f"Warning: Failed to copy license file: {e}")
            return False

    def commit_and_push_files(self, files: list[str], commit_message: str = "chore: add autogenerated docs") -> None:
        """
        Add, commit, and push specified files.

        Args:
            files: List of file paths to add and commit
            commit_message: Commit message to use
        """
        try:
            for file in files:
                subprocess.run(['git', 'add', file], check=True)

            subprocess.run(['git', 'commit', '-m', commit_message], check=True)
            subprocess.run(['git', 'push', 'origin', 'HEAD'], check=True)
            print(f"✓ Committed and pushed: {', '.join(files)}")

        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Failed to commit and push files: {e}")

    def update_repo_description(self, repo_url: str, description: str) -> None:
        """
        Update the repository description.

        Args:
            repo_url: The repository URL
            description: Description to set (will be truncated to 100 chars)
        """
        # Clean up description
        clean_desc = description.strip().replace('\n', ' ').replace('\r', ' ')
        clean_desc = ' '.join(clean_desc.split())  # Remove extra whitespace
        clean_desc = clean_desc[:100]  # Truncate to 100 chars

        try:
            subprocess.run(['gh', 'repo', 'edit', repo_url, '-d', clean_desc], check=True)
            print(f"✓ Updated repository description: {clean_desc}")
        except subprocess.CalledProcessError as e:
            print(f"Warning: Failed to update repository description: {e}")


async def create_github_repo(repo_name: str, readme_content: str = None,
                      description: str = None, is_public: bool = True,
                      license_file_path: str = None) -> str:
    """
    Convenience function to create a GitHub repo with optional README and description.

    Args:
        repo_name: Name of the repository
        readme_content: Content for README.md (optional)
        description: Repository description (optional)
        is_public: Whether repo should be public
        license_file_path: Path to license file to copy

    Returns:
        The HTML URL of the created repository
    """
    creator = GitHubRepoCreator(license_file_path)

    # Create the repository
    repo_url = creator.create_repo(repo_name, is_public)

    files_to_commit = []

    # Create README if content provided
    if readme_content:
        with open('README.md', 'w') as f:
            f.write(readme_content)
        files_to_commit.append('README.md')
        print("✓ README.md created")

    # Copy license if available
    if creator.copy_license():
        files_to_commit.append('LICENSE')

    # Commit and push files if any were created
    if files_to_commit:
        creator.commit_and_push_files(files_to_commit)

    # Update description if provided
    if description:
        creator.update_repo_description(repo_url, description)

    return repo_url


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python github_repo_creator.py <repo-name> [--private]")
        sys.exit(1)

    repo_name = sys.argv[1]
    is_public = "--private" not in sys.argv

    try:
        url = create_github_repo(repo_name, is_public=is_public)
        print(f"\nDone! Your repository is ready at {url}")
    except RuntimeError as e:
        print(f"Error: {e}")
        sys.exit(1)
